## hash技术概述

**概述：hash函数** -> key利用**hash函数**进行存储，key存到**hash table**（是存储空间）

- 关键词：**hash函数、hash table、hash冲突**
- hash技术的本质：即是存储用也是查找用、适合查找与给定值相等的数据、查找效率高
- **hash函数的本质：将原来的数字映射成另一个数字（名词直译：数据通过算法使其散开陈列）**
- hash table的本质：**连续的存储空间**
- hash冲突的本质：**再重新找地址**
- 独立设计好的**hash函数**的**原则**：
  - 符合：**计算简单、存储均匀、冲突少、存储空间利用率高、耗时少**
  - 避免：同样的key对应多个value、key对应的范围查找、冲突问题
  - 附加考虑：key为字符串的处理（转成数字、ASCII、Unicode）
- **hash函数**（的设计方法）
  - **直接定址法： f(key) = a * key + b ; f(key)为散列地址, 接着存储key♡**
    - 采用考虑原因：简单、存储均匀、无冲突、知道关键字分布的情况且查找表小且连续的情况
  - **数字分析法： 1对key进行部分抽取，2对抽取的数据进行处理并获得key的散列地址, 接着存储key♡**
    - 采用考虑原因：知道关键字的分布且适合处理关键字位数比较多的情况且关键字的若干位分布较均匀
  - **平方取中法： 对key进行平方再抽取中间3位(或多位)作为key的散列地址, 接着存储key♡**
    - 采用考虑原因：不知道关键字分布的情况且关键字位数又不是很多的情况
  - **折叠法： 1将key按散列表长度位数进行分割，2将分割各部分叠加求和(不够均匀再进一步处理)，3取后面散列表长度位数作为key的散列地址, 接着存储key♡**
    - 采用考虑原因：不需知道关键字的分布且适合关键字位数较多的情况
  - **除留余数法：f(key) = key mod p , (p<=m) ; f(key)为散列地址, 接着存储key♡♡♡♡♡**
    - 采用考虑原因：最常用，经验为散列表表长m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数
  - **随机数法：f(key) = random(key) ; f(key)为散列地址, 接着存储key♡**
    - 采用考虑原因：关键字长度不等
- **hash函数冲突处理**（的设计方法）：
  - **开放地址法**：
    - **fi(key) = ( f(key) + di ) mod m , (di=1,2,3...,m-1) ; fi(key)为散列地址, 接着存储key**
      - **性能：会产生关键字单向堆积**
    - **fi(key) = ( f(key) + di ) mod m , (di=1², -1², 2², -2²,...,q²,-q²,q<=m/2) ; fi(key)为散列地址, 接着存储key**
      - **性能：不会产生关键字堆积**
    - **fi(key) = ( f(key) + di ) mod m , (di是个固定的随机种子生成的随机数列) ; fi(key)为散列地址, 接着存储key**
      - **性能：不会产生关键字堆积**
  - **再散列函数法：fi(key) = RHi(key) (i=1,2,...,k) , (RH是hash函数集) ; fi(key)为散列地址, 接着存储key**
    - 性能：关键字不会堆积、但冲突计算耗时增加
  - **链地址法：hash table + 同义词链表, 接着存储key**
    - 性能：不存在冲突换址问题、遍历链表使得查找耗时增加
  - **公共溢出法：hash table + 溢出表, 接着存储key**
    - 性能：冲突关键字很少情况下查找性能很高
- 对设计的hash函数进行性能分析：
  - hash函数是否均匀
  - hash函数冲突处理好坏
    - 比如线性探测会产生堆积，没二次探测好 ; 链地址法处理冲突没堆积有最佳平均查找性能
  - hash table的装填因子
    - a = 填入表中的记录个数 / 散列表长度，a越大产生冲突的可能性越大，散列表平均查找长度取决于填装因子，总可以找到一个合适的填装因子以便将平均查找长度限定在一个范围之内，查找时间复杂度真就是O(1)
